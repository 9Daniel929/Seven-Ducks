<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Fortnite-Style Shooter</title>

<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
  }

  #crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 14px;
    height: 14px;
    border: 2px solid white;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
  }

  #hint {
    position: fixed;
    bottom: 20px;
    width: 100%;
    text-align: center;
    color: white;
    font-family: Arial;
    opacity: 0.7;
  }
</style>
</head>

<body>
<div id="crosshair"></div>
<div id="hint">Click to lock mouse • WASD to move • Click to shoot</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
/* ---------- Scene ---------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x6ec6ff);
scene.fog = new THREE.Fog(0x6ec6ff, 20, 120);

/* ---------- Camera ---------- */
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 2, 5);

/* ---------- Renderer ---------- */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

/* ---------- Lights ---------- */
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(30, 50, 30);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
scene.add(sun);

scene.add(new THREE.AmbientLight(0xffffff, 0.4));

/* ---------- Ground ---------- */
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(300, 300),
  new THREE.MeshStandardMaterial({
    color: 0x2ecc71,
    roughness: 0.8
  })
);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

/* ---------- Targets ---------- */
const enemies = [];
for (let i = 0; i < 15; i++) {
  const enemy = new THREE.Mesh(
    new THREE.BoxGeometry(1.5, 1.5, 1.5),
    new THREE.MeshStandardMaterial({
      color: 0xff4757,
      roughness: 0.4,
      metalness: 0.2
    })
  );
  enemy.position.set(
    (Math.random() - 0.5) * 80,
    1,
    (Math.random() - 0.5) * 80
  );
  enemy.castShadow = true;
  enemies.push(enemy);
  scene.add(enemy);
}

/* ---------- Controls ---------- */
const keys = {};
document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

/* ---------- Pointer Lock (Mouse Lock) ---------- */
document.body.addEventListener("click", () => {
  document.body.requestPointerLock();
  shoot();
});

let yaw = 0;
let pitch = 0;

document.addEventListener("mousemove", e => {
  if (document.pointerLockElement === document.body) {
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-1.4, Math.min(1.4, pitch));
    camera.rotation.set(pitch, yaw, 0);
  }
});

/* ---------- Shooting ---------- */
const raycaster = new THREE.Raycaster();
function shoot() {
  raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
  const hits = raycaster.intersectObjects(enemies);
  if (hits.length > 0) {
    scene.remove(hits[0].object);
    enemies.splice(enemies.indexOf(hits[0].object), 1);
  }
}

/* ---------- Movement ---------- */
function movePlayer() {
  const speed = 0.2;
  const dir = new THREE.Vector3();

  camera.getWorldDirection(dir);
  dir.y = 0;
  dir.normalize();

  if (keys["w"]) camera.position.addScaledVector(dir, speed);
  if (keys["s"]) camera.position.addScaledVector(dir, -speed);

  const right = new THREE.Vector3().crossVectors(dir, camera.up);
  if (keys["a"]) camera.position.addScaledVector(right, -speed);
  if (keys["d"]) camera.position.addScaledVector(right, speed);
}

/* ---------- Loop ---------- */
function animate() {
  requestAnimationFrame(animate);
  movePlayer();
  renderer.render(scene, camera);
}
animate();

/* ---------- Resize ---------- */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
